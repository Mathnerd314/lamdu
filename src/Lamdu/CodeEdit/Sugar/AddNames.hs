{-# LANGUAGE GeneralizedNewtypeDeriving, RecordWildCards, TypeFamilies #-}
module Lamdu.CodeEdit.Sugar.AddNames
  ( addToDef
  ) where

import Control.Applicative (Applicative(..), (<$>), (<$))
import Control.Monad.Trans.Reader (Reader, runReader)
import Control.Monad.Trans.State (runState, evalState)
import Control.Monad.Trans.Writer (Writer, runWriter)
import Control.MonadA (MonadA)
import Control.Lens.Operators
import Data.Map (Map)
import Data.Monoid (Monoid(..))
import Data.Store.Guid (Guid)
import Data.Traversable (Traversable, traverse)
import Lamdu.CodeEdit.Sugar.AddNames.CPS (CPS(..))
import Lamdu.CodeEdit.Sugar.NameGen (NameGen)
import Lamdu.CodeEdit.Sugar.Types
import Prelude hiding (pi)
import qualified Control.Lens as Lens
import qualified Control.Monad.Trans.Reader as Reader
import qualified Control.Monad.Trans.Writer as Writer
import qualified Data.Map as Map
import qualified Data.Set as Set
import qualified Lamdu.CodeEdit.Sugar.NameGen as NameGen

type CPSNameConvertor m = Guid -> OldName m -> CPS m (NewName m)
type NameConvertor m = Guid -> OldName m -> m (NewName m)

class MonadA m => MonadNaming m where
  type OldName m
  type NewName m
  opRun :: m (m res -> res)

  opWithParamName :: NameGen.IsDependent -> CPSNameConvertor m
  opWithWhereItemName :: CPSNameConvertor m
  opWithDefName :: CPSNameConvertor m
  opDefName :: NameConvertor m
  opMakeTagName :: NameConvertor m

  opGetParamName :: NameConvertor m
  opGetHiddenParamsName :: NameConvertor m

type StoredName = String
newtype NameCount = NameCount (Map StoredName Int)
instance Monoid NameCount where
  mempty = NameCount Map.empty
  NameCount x `mappend` NameCount y = NameCount $ Map.unionWith (+) x y
evalWriter :: Writer w a -> a
evalWriter = fst . runWriter

-- Pass 0:
data StoredNames = StoredNames
  { storedName :: Maybe StoredName
  , storedNamesWithin :: NameCount
  }
newtype Pass0M a = Pass0M (Writer NameCount a)
  deriving (Functor, Applicative, Monad)
fpTellStoredNames :: NameCount -> Pass0M ()
fpTellStoredNames = Pass0M . Writer.tell
fpListenStoredNames :: Pass0M a -> Pass0M (a, NameCount)
fpListenStoredNames (Pass0M act) = Pass0M $ Writer.listen act
runPass0M :: Pass0M a -> a
runPass0M (Pass0M act) = evalWriter act

instance MonadNaming Pass0M where
  type OldName Pass0M = MStoredName
  type NewName Pass0M = StoredNames
  opRun = pure runPass0M
  opWithParamName _ = cpsCollectStoredNames
  opWithWhereItemName = cpsCollectStoredNames
  opWithDefName = cpsCollectStoredNames
  opGetParamName = collectStoredNames
  opGetHiddenParamsName = collectStoredNames
  opMakeTagName = collectStoredNames
  opDefName = collectStoredNames

pass0Result :: NameCount -> MStoredName -> Pass0M StoredNames
pass0Result storedNameCounts mName =
  StoredNames
  { storedName = mName
  , storedNamesWithin =
    storedNameCounts `mappend` myNameCounts
  }
  <$ fpTellStoredNames myNameCounts
  where
    myNameCounts = NameCount $ maybe Map.empty (`Map.singleton` 1) mName

collectStoredNames :: NameConvertor Pass0M
collectStoredNames _ = pass0Result mempty

cpsCollectStoredNames :: CPSNameConvertor Pass0M
cpsCollectStoredNames _ mName = CPS $ \k -> do
  (res, storedNameCounts) <- p0ListenStoredNames k
  flip (,) res <$> pass0Result storedNameCounts mName

-- Pass 1:
newtype Pass1M a = Pass1M (Reader (NameGen Guid) a)
  deriving (Functor, Applicative, Monad)
runPass1M :: NameGen Guid -> Pass1M a -> a
runPass1M initial (Pass1M act) = runReader act initial
spGetNameGen :: Pass1M (NameGen Guid)
spGetNameGen = Pass1M Reader.ask
spWithNameGen :: NameGen Guid -> Pass1M a -> Pass1M a
spWithNameGen newNameGen (Pass1M act) =
  Pass1M $ (Reader.local . const) newNameGen act

makeStoredName :: StoredName -> NameGen Guid -> (Name, NameGen Guid)
makeStoredName storedName nameGen =
  ( Name StoredName storedName
  , NameGen.ban (Set.singleton storedName) nameGen
  )

makeName ::
  NameGen.IsDependent -> Guid -> StoredNames ->
  NameGen Guid -> (Name, NameGen Guid)
makeName _ _ (StoredNames (Just storedName) _) nameGen = makeStoredName storedName nameGen
makeName isDep guid (StoredNames Nothing (NameCount nameCounts)) nameGen =
  runState
  (Name AutoGeneratedName <$>
   NameGen.newName (`Map.notMember` nameCounts) isDep guid)
  nameGen

instance MonadNaming Pass1M where
  type OldName Pass1M = StoredNames
  type NewName Pass1M = Name
  opRun = do
    nameGen <- spGetNameGen
    pure $ runPass1M nameGen
  opWithParamName = newLocalName
  opWithWhereItemName = newLocalName NameGen.Independent
  opGetParamName _ (StoredNames (Just str) _) = pure $ Name StoredName str
  opGetParamName guid (StoredNames _ _) = do
    nameGen <- spGetNameGen
    pure . Name AutoGeneratedName $
      evalState (NameGen.existingName guid) nameGen
  opGetHiddenParamsName _ (StoredNames mName _) =
    pure $ maybe (Name AutoGeneratedName "params") (Name StoredName) mName
  opMakeTagName = nameByGuid "tag_"
  opWithDefName = newLocalNameByGuid "def_"
  opDefName = nameByGuid "def_"

makeNameByGuid :: Show guid => String -> guid -> StoredNames -> NameGen Guid -> (Name, NameGen Guid)
makeNameByGuid prefix guid (StoredNames Nothing _) curNameGen =
  (makeGuidName prefix guid, curNameGen)
makeNameByGuid _ _ (StoredNames (Just storedName) _) curNameGen =
  makeStoredName storedName curNameGen

newLocalNameHelper :: (NameGen Guid -> (a, NameGen Guid)) -> CPS Pass1M a
newLocalNameHelper nameMaker = CPS $ \k -> do
  curNameGen <- spGetNameGen
  let
    (name, newNameGen) = nameMaker curNameGen
  res <- spWithNameGen newNameGen k
  return (name, res)

newLocalNameByGuid :: String -> Guid -> StoredNames -> CPS Pass1M Name
newLocalNameByGuid prefix guid storedNames = newLocalNameHelper $ makeNameByGuid prefix guid storedNames

newLocalName :: NameGen.IsDependent -> Guid -> StoredNames -> CPS Pass1M Name
newLocalName isDep guid storedNames = newLocalNameHelper $ makeName isDep guid storedNames

nameByGuid :: (Show guid, Applicative f) => String -> guid -> StoredNames -> f Name
nameByGuid _ _ (StoredNames (Just str) _) = pure $ Name StoredName str
nameByGuid prefix guid (StoredNames Nothing _) = pure $ makeGuidName prefix guid

makeGuidName :: Show guid => String -> guid -> Name
makeGuidName prefix guid = Name AutoGeneratedName $ prefix ++ show guid

withFuncParam ::
  (MonadA tm, MonadNaming m) =>
  NameGen.IsDependent ->
  FuncParam (OldName m) tm (Expression (OldName m) tm) ->
  CPS m (FuncParam (NewName m) tm (Expression (NewName m) tm))
withFuncParam isDep fp@FuncParam{..} = CPS $ \k -> do
  mActions <- traverse toFuncParamActions _fpMActions
  typ <- toExpression _fpType
  (name, res) <-
    case _fpVarKind of
    FuncParameter ->
      runCPS (opWithParamName isDep _fpGuid _fpName) k
    FuncFieldParameter ->
      (,) <$> opMakeTagName _fpGuid _fpName <*> k
  pure
    ( fp
      { _fpName = name
      , _fpMActions = mActions
      , _fpType = typ
      }
    , res
    )

toFunc ::
  (MonadA tm, MonadNaming m) =>
  Func (OldName m) tm (Expression (OldName m) tm) ->
  m (Func (NewName m) tm (Expression (NewName m) tm))
toFunc func@Func {..} = do
  (depParams, (params, body)) <-
    runCPS (traverse (withFuncParam NameGen.Dependent) _fDepParams) .
    runCPS (traverse (withFuncParam NameGen.Independent) _fParams) $
    toExpression _fBody
  pure func
    { _fDepParams = depParams
    , _fParams = params
    , _fBody = body
    }

toPi ::
  (MonadA tm, MonadNaming m) =>
  Pi (OldName m) tm (Expression (OldName m) tm) ->
  m (Pi (NewName m) tm (Expression (NewName m) tm))
toPi pi@Pi {..} = do
  (param, resultType) <- runCPS (withFuncParam NameGen.Dependent pParam) $ toExpression pResultType
  pure pi { pParam = param, pResultType = resultType }

toHoleActions ::
  (MonadA tm, MonadNaming m) => HoleActions (OldName m) tm ->
  m (HoleActions (NewName m) tm)
toHoleActions ha@HoleActions {..} = do
  run0 <- opRun
  run1 <- opRun
  let
    toHoleResult = run0 . holeResultConverted toExpression
    toScopeItem (ScopeVar x) = run1 $ ScopeVar <$> toGetVar x
    toScopeItem (ScopeTag x) = run1 $ ScopeTag <$> toTag x
    toScopeItem (ScopeGetParams x) = run1 $ ScopeGetParams <$> toGetParams x
    onMHoleResult = (fmap . fmap) toHoleResult
    result = onMHoleResult <$> _holeResult
    scope = _holeScope & (Lens.mapped . traverse . Lens._1) %~ toScopeItem
  pure ha { _holeScope = scope, _holeResult = result }

toHole ::
  (MonadA tm, MonadNaming m) => Hole (OldName m) tm ->
  m (Hole (NewName m) tm)
toHole = (holeMActions . Lens.traversed) toHoleActions

toInferred ::
  (MonadA tm, MonadNaming m) => Inferred (OldName m) tm (Expression (OldName m) tm) ->
  m (Inferred (NewName m) tm (Expression (NewName m) tm))
toInferred Inferred {..} = do
  value <- toExpression _iValue
  hole <- toHole _iHole
  pure Inferred { _iValue = value, _iHole = hole, .. }

toCollapsed ::
  (MonadA tm, MonadNaming m) =>
  Collapsed (OldName m) tm (Expression (OldName m) tm) ->
  m (Collapsed (NewName m) tm (Expression (NewName m) tm))
toCollapsed Collapsed {..} = do
  compact <- toGetVar _pCompact
  fullExpression <- toExpression _pFullExpression
  pure Collapsed { _pCompact = compact, _pFullExpression = fullExpression, .. }

toTag ::
  MonadNaming m => TagG (OldName m) ->
  m (TagG (NewName m))
toTag (TagG guid oldName) = do
  name <- opMakeTagName guid oldName
  pure $ TagG guid name

toGetVar ::
  MonadNaming m => GetVar (OldName m) tm ->
  m (GetVar (NewName m) tm)
toGetVar getVar@GetVar{..} =
  gvName (f _gvIdentifier) getVar
  where
    f =
      case _gvVarType of
      GetParameter -> opGetParamName
      GetFieldParameter -> opMakeTagName
      GetDefinition -> opDefName

toGetParams ::
  MonadNaming m => GetParams (OldName m) tm ->
  m (GetParams (NewName m) tm)
toGetParams getParams@GetParams{..} =
  gpDefName (opDefName _gpDefGuid) getParams

traverseToExpr ::
  (MonadA tm, MonadNaming m, Traversable t) =>
  (t (Expression (NewName m) tm) -> b) -> t (Expression (OldName m) tm) ->
  m b
traverseToExpr cons body = cons <$> traverse toExpression body

toBody ::
  (MonadA tm, MonadNaming m) =>
  Body (OldName m) tm (Expression (OldName m) tm) ->
  m (Body (NewName m) tm (Expression (NewName m) tm))
toBody (BodyApply hp x)       = traverseToExpr (BodyApply hp) x
toBody (BodySection hp x)     = traverseToExpr (BodySection hp) x
toBody (BodyList x)           = traverseToExpr BodyList x
toBody (BodyRecord x)         = traverseToExpr BodyRecord x
toBody (BodyGetField x)       = traverseToExpr BodyGetField x
toBody (BodyLiteralInteger x) = pure $ BodyLiteralInteger x
toBody (BodyAtom x)           = pure $ BodyAtom x
--
toBody (BodyFunc hp x) = BodyFunc hp <$> toFunc x
toBody (BodyPi hp x) = BodyPi hp <$> toPi x
toBody (BodyHole x) = BodyHole <$> toHole x
toBody (BodyInferred x) = BodyInferred <$> toInferred x
toBody (BodyCollapsed x) = BodyCollapsed <$> toCollapsed x
toBody (BodyTag x) = BodyTag <$> toTag x
toBody (BodyGetVar x) = BodyGetVar <$> toGetVar x
toBody (BodyGetParams x) = BodyGetParams <$> toGetParams x

toPayload ::
  (MonadA tm, MonadNaming m) => Payload (OldName m) tm ->
  m (Payload (NewName m) tm)
toPayload pl@Payload {..} = do
  inferredTypes <- traverse toExpression _plInferredTypes
  nextHole <- traverse toExpression _plNextHole
  pure pl
    { _plInferredTypes = inferredTypes
    , _plNextHole = nextHole
    }

toExpression ::
  (MonadA tm, MonadNaming m) => Expression (OldName m) tm ->
  m (Expression (NewName m) tm)
toExpression expr@Expression{..} = do
  body <- toBody _rBody
  pl <- toPayload _rPayload
  pure expr { _rBody = body, _rPayload = pl }

toFuncParamActions ::
  MonadNaming m => FuncParamActions (OldName m) tm ->
  m (FuncParamActions (NewName m) tm)
toFuncParamActions fpa@FuncParamActions {..} =
  pure fpa { _fpGetExample = error "TODO: examples" }

withWhereItem ::
  (MonadA tm, MonadNaming m) => WhereItem (OldName m) tm ->
  CPS m (WhereItem (NewName m) tm)
withWhereItem item@WhereItem{..} = CPS $ \k -> do
  (name, (value, res)) <-
    runCPS (opWithWhereItemName wiGuid wiName) $
    (,) <$> toDefinitionContent wiValue <*> k
  pure (item { wiValue = value, wiName = name }, res)

toDefinitionContent ::
  (MonadA tm, MonadNaming m) => DefinitionContent (OldName m) tm ->
  m (DefinitionContent (NewName m) tm)
toDefinitionContent def@DefinitionContent{..} = do
  (depParams, (params, (whereItems, body))) <-
    runCPS (traverse (withFuncParam NameGen.Dependent) dDepParams) .
    runCPS (traverse (withFuncParam NameGen.Independent) dParams) .
    runCPS (traverse withWhereItem dWhereItems) $
    toExpression dBody
  pure def
    { dDepParams = depParams
    , dParams = params
    , dBody = body
    , dWhereItems = whereItems
    }

toDefinitionNewType ::
  (MonadA tm, MonadNaming m) => DefinitionNewType (OldName m) tm ->
  m (DefinitionNewType (NewName m) tm)
toDefinitionNewType dnt@DefinitionNewType{..} = do
  newType <- toExpression dntNewType
  pure dnt { dntNewType = newType }

toDefinitionBody ::
  (MonadA tm, MonadNaming m) => DefinitionBody (OldName m) tm ->
  m (DefinitionBody (NewName m) tm)
toDefinitionBody (DefinitionBodyBuiltin bi) =
  pure $ DefinitionBodyBuiltin bi
toDefinitionBody
  (DefinitionBodyExpression
   def@DefinitionExpression {..}) =
    DefinitionBodyExpression <$> do
      content <- toDefinitionContent _deContent
      mNewType <- traverse toDefinitionNewType _deMNewType
      pure def
        { _deContent = content
        , _deMNewType = mNewType
        }

toDef ::
  (MonadA tm, MonadNaming m) => Definition (OldName m) tm ->
  m (Definition (NewName m) tm)
toDef def@Definition {..} = do
  (name, (typ, body)) <-
    runCPS (opWithDefName _drGuid _drName) $
    (,) <$> toExpression _drType <*> toDefinitionBody _drBody
  pure def { _drName = name, _drType = typ, _drBody = body }

addToDef :: MonadA m => DefinitionU m -> DefinitionN m
addToDef = runPass1M NameGen.initial . toDef . runPass0M . toDef
