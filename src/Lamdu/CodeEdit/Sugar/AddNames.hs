{-# LANGUAGE RecordWildCards #-}
module Lamdu.CodeEdit.Sugar.AddNames
  ( toDef
  ) where

import Control.Applicative (pure, (<$>))
import Control.Lens.Operators
import Control.Monad ((<=<))
import Control.Monad.Trans.Class (lift)
import Control.MonadA (MonadA)
import Data.Store.Guid (Guid)
import Data.Traversable (traverse)
import Lamdu.CodeEdit.Sugar.Types
import Prelude hiding (pi)
import qualified Control.Lens as Lens

makeParamName :: MonadA m => Guid -> T m Name
makeParamName _ = pure (Name AutoGeneratedName (error "TODO"))

makeTagName :: MonadA m => Guid -> T m Name
makeTagName _ = pure (Name AutoGeneratedName (error "TAG_TODO"))

toFunc :: MonadA m => Func NoName m expr -> T m (Func Name m expr)
toFunc func@Func {..} = do
  depParams <- traverse toFuncParam _fDepParams
  params <- traverse toFuncParam _fParams
  pure func
    { _fDepParams = depParams
    , _fParams = params
    }

toPi :: MonadA m => Pi NoName m expr -> T m (Pi Name m expr)
toPi pi@Pi {..} = do
  param <- toFuncParam pParam
  pure pi { pParam = param }

toHoleResult ::
  MonadA m => HoleResult NoName m -> T m (HoleResult Name m)
toHoleResult = holeResultConverted toExpression

toScopeItem ::
  MonadA m => ScopeItem NoName m -> T m (ScopeItem Name m)
toScopeItem (ScopeVar getVar) = ScopeVar <$> toGetVar getVar
toScopeItem (ScopeTag tagG) = ScopeTag <$> toTag tagG

toHoleActions ::
  MonadA m => HoleActions NoName m -> T m (HoleActions Name m)
toHoleActions ha@HoleActions {..} = do
  scope <- (traverse . Lens._1) toScopeItem _holeScope
  let result = (lift . traverse toHoleResult =<<) <$> _holeResult
  pure ha { _holeScope = scope, _holeResult = result }

toHole :: MonadA m => Hole NoName m -> T m (Hole Name m)
toHole = (holeMActions . Lens.traversed) toHoleActions

toInferred :: MonadA m => Inferred NoName m expr -> T m (Inferred Name m expr)
toInferred = iHole toHole

toCollapsed :: MonadA m => Collapsed NoName m expr -> T m (Collapsed Name m expr)
toCollapsed = pCompact toGetVar

toTag :: MonadA m => TagG NoName -> T m (TagG Name)
toTag tag = do
  name <- makeTagName $ tag ^. tagGuid
  pure $ tag & tagName .~ name

toGetVar :: MonadA m => GetVar NoName m -> T m (GetVar Name m)
toGetVar getVar@GetVar{..} = do
  name <- makeParamName gvIdentifier
  pure getVar { gvName = name }

toExpressionBody ::
  MonadA m => ExpressionBody NoName m expr -> T m (ExpressionBody Name m expr)
toExpressionBody ExpressionApply {..} = pure ExpressionApply {..}
toExpressionBody ExpressionSection {..} = pure ExpressionSection {..}
toExpressionBody ExpressionLiteralInteger {..} = pure ExpressionLiteralInteger {..}
toExpressionBody ExpressionAtom {..} = pure ExpressionAtom {..}
toExpressionBody ExpressionList {..} = pure ExpressionList {..}
toExpressionBody ExpressionRecord {..} = pure ExpressionRecord {..}
toExpressionBody ExpressionGetField {..} = pure ExpressionGetField {..}
--
toExpressionBody (ExpressionFunc hp func) = ExpressionFunc hp <$> toFunc func
toExpressionBody (ExpressionPi hp pi) = ExpressionPi hp <$> toPi pi
toExpressionBody (ExpressionHole hole) = ExpressionHole <$> toHole hole
toExpressionBody (ExpressionInferred inferred) = ExpressionInferred <$> toInferred inferred
toExpressionBody (ExpressionCollapsed collapsed) = ExpressionCollapsed <$> toCollapsed collapsed
toExpressionBody (ExpressionTag tag) = ExpressionTag <$> toTag tag
toExpressionBody (ExpressionGetVar getVar) = ExpressionGetVar <$> toGetVar getVar

toExpressionP ::
  MonadA m => ExpressionP NoName m pl -> T m (ExpressionP Name m pl)
toExpressionP expr@Expression{..} = do
  body <- traverse toExpressionP =<< toExpressionBody _rExpressionBody
  pure expr { _rExpressionBody = body }

toPayload ::
  MonadA m => Payload NoName m -> T m (Payload Name m)
toPayload pl@Payload {..} = do
  inferredTypes <- traverse toExpression _plInferredTypes
  nextHole <- traverse toExpression _plNextHole
  pure pl
    { _plInferredTypes = inferredTypes
    , _plNextHole = nextHole
    }

toExpression ::
  MonadA m => ExpressionU m -> T m (ExpressionN m)
toExpression = traverse toPayload <=< toExpressionP

toFuncParamActions ::
  MonadA m =>
  FuncParamActions NoName m -> T m (FuncParamActions Name m)
toFuncParamActions fpa@FuncParamActions {..} = do
  pure fpa
    { _fpGetExample = error "TODO: examples" }

toFuncParam ::
  MonadA m => FuncParam NoName m expr ->
  T m (FuncParam Name m expr)
toFuncParam fp@FuncParam{..} = do
  name <- makeParamName _fpGuid
  mActions <- traverse toFuncParamActions _fpMActions
  pure fp
    { _fpName = name
    , _fpMActions = mActions
    }

toFuncParamWithExpr ::
  MonadA m =>
  FuncParam NoName m (ExpressionU m) ->
  T m (FuncParam Name m (ExpressionN m))
toFuncParamWithExpr =
  traverse toExpression <=< toFuncParam

toWhereItem ::
  MonadA m => WhereItem NoName m -> T m (WhereItem Name m)
toWhereItem item@WhereItem{..} = do
  value <- toDefinitionContent wiValue
  pure item { wiValue = value }

toDefinitionContent ::
  MonadA m => DefinitionContent NoName m ->
  T m (DefinitionContent Name m)
toDefinitionContent def@DefinitionContent{..} = do
  depParams <- traverse toFuncParamWithExpr dDepParams
  params <- traverse toFuncParamWithExpr dParams
  body <- toExpression dBody
  whereItems <- traverse toWhereItem dWhereItems
  pure def
    { dDepParams = depParams
    , dParams = params
    , dBody = body
    , dWhereItems = whereItems
    }

toDefinitionNewType ::
  MonadA m => DefinitionNewType NoName m ->
  T m (DefinitionNewType Name m)
toDefinitionNewType dnt@DefinitionNewType{..} = do
  newType <- toExpression dntNewType
  pure dnt { dntNewType = newType }

toDefinitionBody ::
  MonadA m =>
  DefinitionBody NoName m -> T m (DefinitionBody Name m)
toDefinitionBody (DefinitionBodyBuiltin bi) =
  pure $ DefinitionBodyBuiltin bi
toDefinitionBody
  (DefinitionBodyExpression
   def@DefinitionExpression {..}) =
    DefinitionBodyExpression <$> do
      content <- toDefinitionContent _deContent
      mNewType <- traverse toDefinitionNewType _deMNewType
      pure def
        { _deContent = content
        , _deMNewType = mNewType
        }

toDef :: MonadA m => DefinitionU m -> T m (DefinitionN m)
toDef def@Definition {..} = do
  typ <- toExpression _drType
  body <- toDefinitionBody _drBody
  pure def { _drType = typ, _drBody = body }
